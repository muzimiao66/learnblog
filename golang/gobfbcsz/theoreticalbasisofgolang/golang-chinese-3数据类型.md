# 三、词法与数据类型

## 3.2数据类型
### 3.1.6 表达式
&emsp;&emsp;表达式带代表了把操作符和函数作用于操作数的计算方法。

>1.基本表达式
>>- 使用操作数来表示基本表达式。[]int{1,2,3,4,5}[2]
>>- 类型转换表达式。int(v1)+v2
>>- 内建函数调用表达式。len(v3)
>>- 一个基本表达式和选择符号组成。x.f
>>- 索引表达式。[]int{1,2,3,4,5}[2]
>>- 切片符号表达式。[]int{1,2,3,4,5}[1:4]取出了切片[]int{1,2,3,4,5}的第二个到第四
个元素
>>- 类型判断表达式。interface{}(num).(int)
>>- 调用符号表达式。os.Open("/etc/profile")

>2.选择符号和选择表达式
>&emsp;&emsp; 基本表达式x不代表一个代码包的时候，我们才能在它之上应用一个选择符号，就像我们前面提到的基本表达式x.f。
>&emsp;&emsp;空标识符用“_”来表示。
>>对于一个类型T或者对应的指针类型＊T的值x,选择表达式x.f表示类型T的最浅深度（即深度为0）的字段或者方法。这里有两个前提条件：T不能是接口类型；类型T必须要有名称为
f的字段或者方法。不过不能满足这两个前提条件，那么选择表达式x.f就是非法的。
>>对于一个接口类型I的变量X，选择表达式x.f表示赋给x的那个值的方法f.
>>如果x是一个与某个结构体类型对应的指针类型的变量，并且它的值为nil,那么针对表达式x.f的赋值和求职都会产生错误！
>>如果x是一个接口类型的变量且它的值为nil,那么针对表达式x.f的调用和求职都会引起一个运行错误。
>如果x包涵了一个类型为类型为*A的匿名字段，并且A是一个拥有字段或方法f的结构体类型，那么x.f的就是表达式（*x.A).f的一个简写。

### 3.2.3  切片
```golang
//slice1 初始化原值
slice1 = []string{"go","python","java","C","Ruby","Erlang"};
//再次对变量slice1的值进行扩展
slice1 = append(slice1,"Lisp");
```
&emsp;&emsp;这时将会有一个新的数组值被创建并并初始化。这个新的数组值将作为append函数新创建
的切片值的底层数组，并包含原切片值中的全部元素值以及作为扩展内容的所有元素值。
 

&emsp;&emsp;内建函数append的第二个参数是一个可变长参数，append 函数把两个元素类型相同的切片值连接起来。例如：
```golang
slice1 = append(slice2,slice1...);
var slice4 = []string
slice4 = append(slice4,slice1);
```
