# 三、词法与数据类型

## 3.1基本语法
### 3.1.6 表达式
&emsp;&emsp;表达式带代表了把操作符和函数作用于操作数的计算方法。

>1. 基本表达式
>>- 使用操作数来表示基本表达式。[]int{1,2,3,4,5}[2]
>>- 类型转换表达式。int(v1)+v2
>>- 内建函数调用表达式。len(v3)
>>- 一个基本表达式和选择符号组成。x.f
>>- 索引表达式。[]int{1,2,3,4,5}[2]
>>- 切片符号表达式。[]int{1,2,3,4,5}[1:4]取出了切片[]int{1,2,3,4,5}的第二个到第四
个元素
>>- 类型判断表达式。interface{}(num).(int)
>>- 调用符号表达式。os.Open("/etc/profile")   

>2.选择符号和选择表达式  
>&emsp;&emsp; 基本表达式x不代表一个代码包的时候，我们才能在它之上应用一个选择符号，就像我们前面提到的基本表达式x.f。  
>&emsp;&emsp;空标识符用“_”来表示。
>>- 对于一个类型T或者对应的指针类型＊T的值x,选择表达式x.f表示类型T的最浅深度（即深度为0）的字段或者方法。这里有两个前提条件：T不能是接口类型；类型T必须要有名称为
f的字段或者方法。不过不能满足这两个前提条件，那么选择表达式x.f就是非法的。
>>- 对于一个接口类型I的变量X，选择表达式x.f表示赋给x的那个值的方法f.
>>- 如果x是一个与某个结构体类型对应的指针类型的变量，并且它的值为nil,那么针对表达式x.f的赋值和求职都会产生错误！
>>- 如果x是一个接口类型的变量且它的值为nil,那么针对表达式x.f的调用和求职都会引起一个运行错误。  
>如果x包涵了一个类型为类型为*A的匿名字段，并且A是一个拥有字段或方法f的结构体类型，那么x.f的就是表达式（*x.A).f的一个简写。  

>3. 索引符号和索引表达式
>>注意：当字典类型的变量a的值为nil时，求职表达式a[x]并不会发生任何错误，但是在这种情况下对a[x]进行赋值却会引起一个运行错误。  

>4.切片符号和切片表达式  
>&emsp;&emsp;切片表达式可以操作字符串、数组、数组对指针以及切片类型的值。对于这
样的一个类型的值a,切片表达式形如a[x:y:z]. a是切片符号[x:y]的操作对象。其中,x代表了切片的元素下届索引，y代表了切片的元素上界索引，而z代表了切片的容量上界索引  
>&emsp;&emsp;0 <= 元素下届索引 <= 元素上界索引 <= 容量上界索引 <= 操作对象的容量
  
>5.类型判断  
>&emsp;&emsp;如果T不是一个接口类型，那么x.(T)将会判断x的动态类型是否与类型T一致。  
>&emsp;&emsp;当T是一个接口类型的时候，表达式x.(T)将会判断x的动态类型是否实现了接口类型T  
>&emsp;&emsp;注意，只有在程序运行期间，x的动态类型才能被获知，而在编译期间只能确定T所属的类型。  
>&emsp;&emsp;v,ok := x.(T) 即使类型判断失败也不会引发运行错误。  

>6. 调用  
>>f(g(a1, a2, a3))  
>>函数g的结果与函数f的参数在数量必须相同。
>>对函数f的调用表达式中除了函数g的调用表达式之外不能再出现其它的参数。
>>函数g至少有一个参数。
>>如果函数在参数列表的最后一个是可变长参数，那么Go语言会在把函数g的结果作为函数f的普通参数传递给f之后，再尝试把剩余的结果传递给函数f的可变长参数。  

>7. 可变长参数  
>```golang
>appendIAbsent([]string{"A","B","c"},[]string{"C","B","E"}...)
>appendIAbsent([]string{"A","B","C"},s...)
>````

## 3.2数据类型
## 3.2.1基本数据类型  
>1. 布尔类型  
>2. 数值类型  
## 3.2.2 数组  
>1. 类型表示法  
>>一个长度为n、元素类型为T的数组类型：[n]T  
>>```golang
>>[5]struct{name,address string} //"struct{ ... }"是用于自定义匿名结构体类型的类型字面亮
>>```  
>2. 值表示法
>>```golang
>>[6]string{"go","python","java","C","C++","PHP"} //表示了一个长度为6、元素类型
>>为string 的数组类型，且已经包含了6个元素。
>>``` 
### 3.2.3  切片  
>1. 类型表示法  
>> 一个元素类型为T的切片类型字面量表示为 []T  
>> 元素类型为rune的切片类型 []rune   
>> 匿名结构体类型作为切片类型的元素类型: []struct { name, department string}  
>2. 值表示法
>> []string{"GO", "Python", "Java", "C", "C++", "PHP"}
>> 切片值的长度还是需要在int 类型所能表示的非负值范围之内的。
>3. 属性和基本操作  
>>在初始化之前，一切切片类型的变量值为nil  
>>在切片类型和零值上（即nil）上应用内建函数len将得到0.  
>>一个切片一旦被初始化，就会与一个包含了其中元素值的数组值相关联，这个数组值被称为饮用它的切片值的底层数组。  
>>如果把一个切片值复制成多个，那么这些切片值索引用的都会是同一个底层数组，对切片值中元素的元素值修改，实质上就是对其底层数组上对应元素的修改。
>>一个切片值的底层数据结构中包含了一个指向底层数组的指针类型值，一个代表了切片长度的int类型值和一个代表了切片容量的int类型值    
>>在切片值中存储者指向其底层数组的指针。这个指针体现了他们之间的饮用关系。我们在使用复合字面量的初始化一个切片值的时候，首先创建的是这个切片值所引用的底层数组。这个底层数组与这个切片值有着相同的元素类型、元素值及其排列顺序和长度。  
>>切片表达式的作用并不是复制数组值中的某个连续片段所包含的元素值，而是创建一个新的切片值.  
>> slice2 := array1[3:];  
>> slice2 的值中那个指针指向了array1的值中第4个元素，而从这个元素到array1 的值中的最后元素的元素计数值是3.  
>> 切片值的容量的含义是其能够访问到的当前底层数组中的元素值的最大数量。
	 
```golang
//slice1 初始化原值
slice1 = []string{"go","python","java","C","Ruby","Erlang"};
//再次对变量slice1的值进行扩展
slice1 = append(slice1,"Lisp");
```
&emsp;&emsp;这时将会有一个新的数组值被创建并并初始化。这个新的数组值将作为append函数新创建
的切片值的底层数组，并包含原切片值中的全部元素值以及作为扩展内容的所有元素值。
 

&emsp;&emsp;内建函数append的第二个参数是一个可变长参数，append 函数把两个元素类型相同的切片值连接起来。例如：
```golang
slice1 = append(slice2,slice1...);
var slice4 = []string
slice4 = append(slice4,slice1);
```
